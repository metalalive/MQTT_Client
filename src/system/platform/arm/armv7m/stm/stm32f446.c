#include "mqtt_include.h"

// Private macro -------------------------------------------------------------
// TODO: figure out why Rx buffer size less than 0x200 bytes could lead to packet loss
#define  HAL_DMA_RECV_BUF_SIZE  0x280

// Private variables ---------------------------------------------------------
extern  const byte   mqttAuthInitHour   ;
extern  const byte   mqttAuthInitMinutes;
extern  const byte   mqttAuthInitSeconds;
extern  const byte   mqttAuthInitMonth;
extern  const byte   mqttAuthInitDate ;
extern  const word16 mqttAuthInitYear ;
// data structure for RTC (Real-Time Calendar), for getting date time
static  RTC_HandleTypeDef   hrtc;
// timer used for other peripherals in STM32F446 development board
static  TIM_HandleTypeDef   htim2;
// get rough response data from ESP device.
static  uint8_t   recv_data_buf[ HAL_DMA_RECV_BUF_SIZE ]; 
// in each system port, DMA/UART ISR should specify starting offset 
// and number of characters copying from network module (e.g. ESP AT software). 
static  uint16_t  dma_buf_num_char_copied = 0;
static  uint16_t  dma_buf_cpy_offset_next = 0;
static  uint16_t  dma_buf_cpy_offset_curr = 0;

static  uint8_t  platform_stm32_hal_init_flag = 0;

// ---- external configuration functions ----
extern HAL_StatusTypeDef  SystemClock_Config(void);
extern HAL_StatusTypeDef  STM32_HAL_GPIO_Init( void );
extern HAL_StatusTypeDef  STM32_HAL_DMA_Init( void );
extern HAL_StatusTypeDef  STM32_HAL_UART_Init( void );
extern HAL_StatusTypeDef  STM32_HAL_UART_DeInit( void );
extern UART_HandleTypeDef *STM32_config_UART(void);
extern DMA_HandleTypeDef  *STM32_config_DMA4UART(void);

// @brief  This function configures the TIM2 as a time base source. 
//         The time source is configured  to have 1ms time base with a dedicated 
//         Tick interrupt priority. 
// @note   This function is called  automatically at the beginning of program after
//         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
// @param  TickPriority: Tick interrupt priority.
// @retval HAL status
// 
// [Important Note]
// * this function here will overwrite the one generated by STM32CubeMX, the generated one is usually
//   implemented at:  Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal.c
// * this function can be called by STM32_HAL_Init() or HAL_RCC_ClockConfig() 
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
    // TODO, remove this overwrite , use HAL default implementation instead
    RCC_ClkInitTypeDef    clkconfig;
    uint32_t              uwTimclock = 0;
    uint32_t              uwPrescalerValue = 0;
    uint32_t              pFLatency;
    
    /*Configure the TIM2 IRQ priority */
    HAL_NVIC_SetPriority(TIM2_IRQn, TickPriority ,0); 
    
    /* Enable TIM2 clock */
    __HAL_RCC_TIM2_CLK_ENABLE();
    
    /* Get clock configuration */
    HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
    
    /* Compute TIM2 clock */
    uwTimclock = HAL_RCC_GetPCLK1Freq();
     
    /* Compute the prescaler value to have TIM2 counter clock equal to 1MHz */
    uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
    
    /* Initialize TIM2 */
    htim2.Instance = TIM2;
    
    /* Initialize TIMx peripheral as follow:
    + Period = [(TIM2CLK/1000) - 1]. to have a (1/1000) s time base.
    + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
    + ClockDivision = 0
    + Counter direction = Up
    */
    htim2.Init.Period = (1000000 / 1000) - 1;
    htim2.Init.Prescaler = uwPrescalerValue;
    htim2.Init.ClockDivision = 0;
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    if(HAL_TIM_Base_Init(&htim2) == HAL_OK) {
      /* Start the TIM time Base generation in interrupt mode */
      return HAL_TIM_Base_Start_IT(&htim2);
    }
    
    /* Return function status */
    return HAL_ERROR;
} // end of HAL_InitTick



// Initializes the Global MSP.
static void STM32_HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();
}

// @brief  This function is used to initialize the HAL Library; it must be the first 
//         instruction to be executed in the main program (before to call any other
//         HAL function), it performs the following:
//           Configure the Flash prefetch, instruction and Data caches.
//           Configures the SysTick to generate an interrupt each 1 millisecond,
//           which is clocked by the HSI (at this stage, the clock is not yet
//           configured and thus the system is running from the internal HSI at 16 MHz).
//           Set NVIC Group Priority to 4.
//           Calls the STM32_HAL_MspInit() callback function defined in user file 
//           "stm32f4xx_hal_msp.c" to do the global low level hardware initialization 
//            
// @note   SysTick is used as time base for the HAL_Delay() function, the application
//         need to ensure that the SysTick time base is always set to 1 millisecond
//         to have correct HAL operation.
// @retval HAL status
// 
static HAL_StatusTypeDef STM32_HAL_Init(void)
{
    // Configure Flash prefetch, Instruction cache, Data cache
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
    __HAL_FLASH_DATA_CACHE_ENABLE();
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();

    // Set Interrupt Group Priority 
    HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

    // Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) 
    HAL_InitTick(TICK_INT_PRIORITY);

    // Init the low level hardware 
    STM32_HAL_MspInit();

    // Return function status 
    return HAL_OK;
} // end of STM32_HAL_Init


// will be called by HAL_RTC_Init
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
    if(hrtc->Instance==RTC) {
        // Peripheral clock enable
        __HAL_RCC_RTC_ENABLE();
    }
} // end of HAL_RTC_MspInit

// @brief  Suspend Tick increment.
// @note   Disable the tick increment by disabling TIM2 update interrupt.
// @param  None
// @retval None
void HAL_SuspendTick(void)
{
    //  Disable TIM2 update Interrupt 
    __HAL_TIM_DISABLE_IT(&htim2, TIM_IT_UPDATE);                                                  
}


// @brief  Resume Tick increment.
// @note   Enable the tick increment by Enabling TIM2 update interrupt.
// @param  None
// @retval None
void HAL_ResumeTick(void)
{
    /* Enable TIM2 Update interrupt */
    __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);
}



// brief This function handles Non maskable interrupt.
void NMI_Handler(void)
{}

// brief This function handles Pre-fetch fault, memory access fault.
void BusFault_Handler(void) {
    while (1);
}



// brief This function handles Undefined instruction or illegal state.
void UsageFault_Handler(void) {
    while (1);
}


// brief This function handles Debug monitor.
void DebugMon_Handler(void)
{}

// brief This function handles TIM2 global interrupt.
void TIM2_IRQHandler(void) {
    HAL_TIM_IRQHandler(&htim2);
}

void STM32_generic_DMAstream_IRQHandler(DMA_HandleTypeDef *hdma) {
    HAL_DMA_IRQHandler(hdma);
}

void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{}

// executed by DMA Transmission completion (TC) event interrupt
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    UART_HandleTypeDef *uart_cfg = STM32_config_UART();
    if( huart == uart_cfg) {
        dma_buf_num_char_copied  = HAL_DMA_RECV_BUF_SIZE  -  dma_buf_cpy_offset_curr;
        mqttSysPktRecvHandler( (huart->pRxBuffPtr + dma_buf_cpy_offset_curr), dma_buf_num_char_copied );
        dma_buf_cpy_offset_curr = 0;
    }
}

// UART Rx interrupt service routine in this test
void STM32_generic_USART_IRQHandler(UART_HandleTypeDef *uart_cfg) {
    HAL_UART_IRQHandler(uart_cfg);
    // check if Idle flag is set, if idle line detection event leads to this interrupt.
    if ( __HAL_UART_GET_FLAG( uart_cfg, UART_FLAG_IDLE ) ) {
        // clear current IDLE-detection interrupt.
        __HAL_UART_CLEAR_IDLEFLAG( uart_cfg );
        DMA_HandleTypeDef  *uart3_rx = STM32_config_DMA4UART();
        // calculate received data bytes & its length, and pass it to higher-level handling function.
        dma_buf_cpy_offset_next = HAL_DMA_RECV_BUF_SIZE - __HAL_DMA_GET_COUNTER( uart3_rx );
        if(dma_buf_cpy_offset_next > dma_buf_cpy_offset_curr && uart_cfg-> pRxBuffPtr != NULL) {
            dma_buf_num_char_copied  = dma_buf_cpy_offset_next -  dma_buf_cpy_offset_curr;
            mqttSysPktRecvHandler( (uart_cfg->pRxBuffPtr + dma_buf_cpy_offset_curr), dma_buf_num_char_copied );
        } // otherwise, skip the received data from this interrupt, TODO: figure out if that's hardware error ?
        dma_buf_cpy_offset_curr = dma_buf_cpy_offset_next;
    } 
} // end of USART3_IRQHandler


static HAL_StatusTypeDef  STM32_HAL_periph_Init( void )
{
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    HAL_StatusTypeDef result = STM32_HAL_UART_Init();
    if (result != HAL_OK) {
        return result;
    }
    result = STM32_HAL_DMA_Init();
    if (result != HAL_OK) {
        return result;
    }
    return STM32_HAL_GPIO_Init();
} // end of STM32_HAL_periph_Init 

static HAL_StatusTypeDef  STM32_HAL_periph_Deinit( void ) {
    return STM32_HAL_UART_DeInit();
}


static HAL_StatusTypeDef STM32_HAL_RTC_Init(void)
{ // Initialize RTC and set the Time and Date
    HAL_StatusTypeDef status = HAL_OK;
    RTC_TimeTypeDef sTime = {0};
    RTC_DateTypeDef sDate = {0};

    hrtc.Instance = RTC;
    hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
    hrtc.Init.AsynchPrediv = 127;
    hrtc.Init.SynchPrediv = 255;
    hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
    hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
    hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
    status = HAL_RTC_Init(&hrtc);

    if(status != HAL_OK) { goto done; }
    sTime.Hours   = mqttAuthInitHour   ; // feed initial date/time from host system
    sTime.Minutes = mqttAuthInitMinutes;
    sTime.Seconds = mqttAuthInitSeconds;
    sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
    sTime.StoreOperation = RTC_STOREOPERATION_RESET;
    status = HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD);
    if(status != HAL_OK) { goto done; }

    sDate.WeekDay = RTC_WEEKDAY_TUESDAY; // this implementation doesn't check what weekday it is today, ignore this value
    sDate.Month   = mqttAuthInitMonth; // can be from RTC_MONTH_JANUARY to RTC_MONTH_DECEMBER
    sDate.Date    = mqttAuthInitDate;
    sDate.Year    = mqttAuthInitYear & 0xff; // seems like UTC time format
    status = HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD);
done:
    return status;
} // end of STM32_HAL_RTC_Init


mqttRespStatus   mqttPlatformPktRecvEnable( void )
{
    mqttRespStatus     response   = MQTT_RESP_OK;
    HAL_StatusTypeDef  status_chk = HAL_ERROR;
    UART_HandleTypeDef *uart_cfg = STM32_config_UART();
    dma_buf_num_char_copied  = 0;
    dma_buf_cpy_offset_next  = 0;
    dma_buf_cpy_offset_curr  = 0;
    status_chk = HAL_UART_Receive_DMA( uart_cfg, (uint8_t *)&recv_data_buf[0], HAL_DMA_RECV_BUF_SIZE );
    switch(status_chk) {
        case HAL_OK       : response = MQTT_RESP_OK     ;   break; 
        case HAL_ERROR    : response = MQTT_RESP_ERR    ;   break; 
        case HAL_BUSY     : response = MQTT_RESP_BUSY   ;   break; 
        case HAL_TIMEOUT  : response = MQTT_RESP_TIMEOUT;   break; 
        default           : response = MQTT_RESP_ERR    ;   break;
    }
    return response;
} // end of mqttPlatformPktRecvEnable 



mqttRespStatus   mqttPlatformPktRecvDisable( void )
{
    mqttRespStatus     response   = MQTT_RESP_OK;
    HAL_StatusTypeDef  status_chk = HAL_ERROR;
    UART_HandleTypeDef *uart_cfg = STM32_config_UART();
    status_chk = HAL_UART_DMAStop( uart_cfg );
    ESP_MEMSET( (void *)&recv_data_buf, 0x00, HAL_DMA_RECV_BUF_SIZE );
    switch(status_chk) {
        case HAL_OK       : response = MQTT_RESP_OK     ;   break; 
        case HAL_ERROR    : response = MQTT_RESP_ERR    ;   break; 
        case HAL_BUSY     : response = MQTT_RESP_BUSY   ;   break; 
        case HAL_TIMEOUT  : response = MQTT_RESP_TIMEOUT;   break; 
        default           : response = MQTT_RESP_ERR    ;   break;
    }
    return response;
} // end of mqttPlatformPktRecvDisable 



mqttRespStatus  mqttPlatformPktSend( void* data, size_t len, uint32_t timeout )
{
    mqttRespStatus     response   = MQTT_RESP_OK;
    HAL_StatusTypeDef  status_chk = HAL_ERROR;
    UART_HandleTypeDef *uart_cfg = STM32_config_UART();
    status_chk  = HAL_UART_Transmit( uart_cfg, (uint8_t* )data, len, timeout );
    switch(status_chk) {
        case HAL_OK       : response = MQTT_RESP_OK     ;   break; 
        case HAL_ERROR    : response = MQTT_RESP_ERR    ;   break; 
        case HAL_BUSY     : response = MQTT_RESP_BUSY   ;   break; 
        case HAL_TIMEOUT  : response = MQTT_RESP_TIMEOUT;   break; 
        default           : response = MQTT_RESP_ERR    ;   break;
    }
    return response;
} // end of mqttPlatformPktSend



// PB4 can be wired to reset pin (RST) of network device.
mqttRespStatus  mqttPlatformNetworkModRst( uint8_t state )
{
    // at here, state = 0 means reset assertion, non-zero value means reset de-assertion.
    GPIO_PinState pinstate = state==0x0 ? GPIO_PIN_RESET: GPIO_PIN_SET;
    HAL_GPIO_WritePin( GPIOB, GPIO_PIN_9, pinstate );
    // FIXME, TODO, make pins to entropy device configuarable.
    // currnetly tied to PB9, not ideal
    return  MQTT_RESP_OK;
} // end of mqttPlatformNetworkModRst



// In this implementation, PC8, PC9 are wired to external device that provides source of randomness.
// Note that the number of pins to use SHOULD depend on what sensor devices or electrical components
// you used to your random number generator (RNG) implementation.
//
// mqttPlatformGetEntropy() in this file provides a sample to show one of many possible ways to entropy
// implementation (source of randomness) , e.g. you wire PC8, PC9 to a sonar sensor HC-SR04 producing
// electrical noise, then feed the noise to your embedded board to generate random bit sequence.
// This can be useful for those embedded boards that don't include built-in hardware RNG.
//
// You should modify the code here based on your hardware set-up.
mqttRespStatus  mqttPlatformGetEntropy(mqttStr_t *out)
{
    if((out==NULL) || (out->data==NULL) || (out->len < 1) || (out->len > MQTT_MAX_BYTES_ENTROPY)) {
        return MQTT_RESP_ERRARGS;
    }
    word32   start_time = 0, stop_time  = 0;
    word32   tmp = 0,  idx = 0, prev_wr_idx = 0, wr_idx = 0, wr_offset = 0;

    const  word32  max_wait_time   = HAL_RCC_GetPCLK1Freq() >> 5;
    GPIO_PinState  echo_state;
    const  uint8_t nbits_grab = 2; // grab 2 bits every time when we read from entropy
    word32         num_iterations = (out->len << 3) / nbits_grab;

    // FIXME, TODO, make pins to entropy device configuarable.
    // currnetly tied to PC8 and PC9, not ideal
    for(idx=0; idx<num_iterations; idx++) {
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, GPIO_PIN_SET);
        mqttSysDelay(1);
        HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, GPIO_PIN_RESET);
        tmp = max_wait_time;
        do { // wait for signal assertion on ECHO pin
            start_time = __HAL_TIM_GET_COUNTER(&htim2);
            echo_state = HAL_GPIO_ReadPin( GPIOC, GPIO_PIN_9 );
            tmp--;
        } while(echo_state == GPIO_PIN_RESET && tmp > 0);
        if(tmp==0) { return MQTT_RESP_TIMEOUT; }
        tmp = max_wait_time;
        do {// wait for signal de-assertion on ECHO pin
            tmp--;
            echo_state = HAL_GPIO_ReadPin( GPIOC, GPIO_PIN_9 );
            stop_time  = __HAL_TIM_GET_COUNTER(&htim2);
        } while(echo_state == GPIO_PIN_SET && tmp > 0);
        if(tmp==0) { return MQTT_RESP_TIMEOUT; }
        tmp  = (stop_time < start_time) ? (htim2.Init.Period - start_time + stop_time) : (stop_time - start_time);
        tmp &= XGET_BITMASK(nbits_grab);
        wr_idx    = (idx * nbits_grab) >> 3;
        wr_offset = (idx * nbits_grab) % 8;
        if(prev_wr_idx != wr_idx) { out->data[wr_idx] = 0; }
        out->data[wr_idx] |= (tmp << wr_offset);
        prev_wr_idx  = wr_idx;
    } // end of foop-loop statement
    return   MQTT_RESP_OK;
} // end of mqttPlatformGetEntropy



mqttRespStatus  mqttPlatformGetDateTime(mqttDateTime_t *out)
{
    if(out == NULL) { return MQTT_RESP_ERRARGS; }
    HAL_StatusTypeDef status = HAL_OK;
    RTC_TimeTypeDef sTime = {0};
    RTC_DateTypeDef sDate = {0};
    status = HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BCD);
    if(status != HAL_OK) { goto done; }
    out->hour   = sTime.Hours;
    out->minite = sTime.Minutes;
    out->second = sTime.Seconds;
    status = HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BCD);
    if(status != HAL_OK) { goto done; }
    out->month   = sDate.Month;
    out->date    = sDate.Date ;
    out->year[1] = sDate.Year ;
    out->year[0] = 0x20; // TODO : find better way to implement this
done:
    return (status == HAL_OK ? MQTT_RESP_OK : MQTT_RESP_ERR);
} // end of mqttPlatformGetDateTime


mqttRespStatus  mqttPlatformInit( void ) {
    HAL_StatusTypeDef  status = HAL_OK;
    // MCU Configuration--------------------------------------------------------  
    if(platform_stm32_hal_init_flag > 0) { // init count goes from 0x1 to 0x8
        STM32_HAL_periph_Deinit();
    } else {
        platform_stm32_hal_init_flag = 1;
        // Reset of all peripherals, Initializes the Flash interface and the Systick.
        STM32_HAL_Init();
        // Configure the system clock
        status = SystemClock_Config();
    }
    // Configure peripherals that will be used in this MQTT implementation
    if(status == HAL_OK) {
        status = STM32_HAL_periph_Init();
    }
    if(status == HAL_OK) {
        status = STM32_HAL_RTC_Init();
    }
    return  (status == HAL_OK ? MQTT_RESP_OK : MQTT_RESP_ERR );
} // end of mqttPlatformInit

mqttRespStatus  mqttPlatformDeInit( void ) {
    return   MQTT_RESP_OK ;
}

