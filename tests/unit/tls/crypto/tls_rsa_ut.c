#include "mqtt_include.h"

#define DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN  0x113
#define DER_ENCODED_RSA_PRIVKEY_RAWBYTES_LEN 0x4a8

static const byte mock_DER_encoded_RSA_pubkey_data[DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN] = {
    0x03,
    0x82,
    0x01,
    0x0f,
    0x00,
    0x30,
    0x82,
    0x01,
    0x0a,
    0x02,
    0x82,
    0x01,
    0x01, // length field of
          // modulus (N) of
          // public key =
          // 0x101
    0x00, // start of modulus (N) of public key, the first byte must be NULL
    0xc2,
    0x60,
    0xc0,
    0x7e,
    0x5f,
    0xe6,
    0xc6,
    0x21,
    0x45,
    0xa9,
    0x86,
    0x62,
    0x65,
    0xcc,
    0x01,
    0x1f,
    0xd2,
    0xb1,
    0xe4,
    0xef,
    0x46,
    0xac,
    0xaa,
    0x3c,
    0xd0,
    0x46,
    0x6a,
    0xbb,
    0x13,
    0x84,
    0xde,
    0xb5,
    0x29,
    0x57,
    0x6f,
    0xf3,
    0x21,
    0x42,
    0xef,
    0x42,
    0x45,
    0x9c,
    0x60,
    0x0a,
    0xa6,
    0x0f,
    0x23,
    0xe3,
    0x9d,
    0x56,
    0xa7,
    0xa9,
    0x78,
    0x29,
    0x3a,
    0x8f,
    0x1e,
    0x1c,
    0xf6,
    0xda,
    0x90,
    0x59,
    0xd9,
    0x21,
    0x91,
    0x86,
    0x1c,
    0x3d,
    0x1f,
    0x93,
    0xbb,
    0xdc,
    0x9c,
    0x98,
    0x89,
    0x70,
    0x7e,
    0x11,
    0xee,
    0xf5,
    0xdc,
    0x29,
    0x60,
    0xaf,
    0x66,
    0xab,
    0x5d,
    0x9c,
    0x19,
    0x04,
    0x2b,
    0x6b,
    0x24,
    0xe6,
    0x9e,
    0x01,
    0x35,
    0xd8,
    0x63,
    0x1a,
    0xe9,
    0xd8,
    0x9d,
    0x57,
    0x92,
    0x66,
    0xf0,
    0xba,
    0x1e,
    0x14,
    0x7d,
    0x12,
    0x07,
    0x9d,
    0x95,
    0xf5,
    0x65,
    0xad,
    0x83,
    0x44,
    0x4e,
    0xd9,
    0x78,
    0x34,
    0x7b,
    0xac,
    0x25,
    0x67,
    0xfc,
    0x8c,
    0xb1,
    0x4f,
    0x34,
    0x9d,
    0xca,
    0x61,
    0xb8,
    0xcf,
    0xbd,
    0xdd,
    0x17,
    0xdd,
    0xbc,
    0xc5,
    0x0e,
    0x74,
    0xe2,
    0xe2,
    0x78,
    0x12,
    0x92,
    0x79,
    0x55,
    0x83,
    0x9b,
    0xf5,
    0xf1,
    0x3f,
    0x97,
    0xb0,
    0x55,
    0x69,
    0xe6,
    0x6f,
    0x3a,
    0x8d,
    0x63,
    0xf5,
    0x50,
    0x7c,
    0xf2,
    0xa6,
    0x3a,
    0x10,
    0xc2,
    0x35,
    0xc1,
    0x58,
    0x3e,
    0x33,
    0x09,
    0x0f,
    0xe1,
    0x67,
    0xb2,
    0x1e,
    0xa2,
    0xa0,
    0xc4,
    0x27,
    0xa4,
    0x3d,
    0x1a,
    0xad,
    0xf8,
    0x4f,
    0xa4,
    0x41,
    0xfc,
    0x8c,
    0xae,
    0x3b,
    0xef,
    0x87,
    0x79,
    0xc8,
    0x5a,
    0x6d,
    0x23,
    0xd7,
    0xb5,
    0x7d,
    0xd4,
    0x88,
    0x6c,
    0xec,
    0x45,
    0xcf,
    0xca,
    0x05,
    0xda,
    0xb3,
    0x41,
    0x38,
    0xd0,
    0x97,
    0x45,
    0xec,
    0x2d,
    0xa4,
    0x07,
    0xf7,
    0x16,
    0x5c,
    0x78,
    0xcc,
    0x5f,
    0xd1,
    0xb0,
    0x4f,
    0x02,
    0xc0,
    0x01,
    0x57,
    0x1d,
    0x36,
    0x60,
    0xfb,
    0x0e,
    0x17,
    0x68,
    0x82,
    0x78,
    0x11,
    0x9b,
    0x9f,
    0x02,
    0x03, // length field of exponent (e) of public key = 0x3
    0x01,
    0x00,
    0x01,
}; // end of mock_DER_encoded_RSA_pubkey_data

static const word16 mock_DER_encoded_RSA_pubkey_N_offset = 13;
static const word16 mock_DER_encoded_RSA_pubkey_N_len = 0x101;
static const word16 mock_DER_encoded_RSA_pubkey_e_offset = 0x110;
static const word16 mock_DER_encoded_RSA_pubkey_e_len = 0x3;

static const byte mock_DER_encoded_RSA_privkey_data[DER_ENCODED_RSA_PRIVKEY_RAWBYTES_LEN] = {
    0x30, 0x82, 0x04, 0xa4, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x01,
    0x00, // start byte of modulus (N), which should be NULL
    0xc2, 0x60, 0xc0, 0x7e, 0x5f, 0xe6, 0xc6, 0x21, 0x45, 0xa9, 0x86, 0x62, 0x65, 0xcc, 0x01,
    0x1f, 0xd2, 0xb1, 0xe4, 0xef, 0x46, 0xac, 0xaa, 0x3c, 0xd0, 0x46, 0x6a, 0xbb, 0x13, 0x84,
    0xde, 0xb5, 0x29, 0x57, 0x6f, 0xf3, 0x21, 0x42, 0xef, 0x42, 0x45, 0x9c, 0x60, 0x0a, 0xa6,
    0x0f, 0x23, 0xe3, 0x9d, 0x56, 0xa7, 0xa9, 0x78, 0x29, 0x3a, 0x8f, 0x1e, 0x1c, 0xf6, 0xda,
    0x90, 0x59, 0xd9, 0x21, 0x91, 0x86, 0x1c, 0x3d, 0x1f, 0x93, 0xbb, 0xdc, 0x9c, 0x98, 0x89,
    0x70, 0x7e, 0x11, 0xee, 0xf5, 0xdc, 0x29, 0x60, 0xaf, 0x66, 0xab, 0x5d, 0x9c, 0x19, 0x04,
    0x2b, 0x6b, 0x24, 0xe6, 0x9e, 0x01, 0x35, 0xd8, 0x63, 0x1a, 0xe9, 0xd8, 0x9d, 0x57, 0x92,
    0x66, 0xf0, 0xba, 0x1e, 0x14, 0x7d, 0x12, 0x07, 0x9d, 0x95, 0xf5, 0x65, 0xad, 0x83, 0x44,
    0x4e, 0xd9, 0x78, 0x34, 0x7b, 0xac, 0x25, 0x67, 0xfc, 0x8c, 0xb1, 0x4f, 0x34, 0x9d, 0xca,
    0x61, 0xb8, 0xcf, 0xbd, 0xdd, 0x17, 0xdd, 0xbc, 0xc5, 0x0e, 0x74, 0xe2, 0xe2, 0x78, 0x12,
    0x92, 0x79, 0x55, 0x83, 0x9b, 0xf5, 0xf1, 0x3f, 0x97, 0xb0, 0x55, 0x69, 0xe6, 0x6f, 0x3a,
    0x8d, 0x63, 0xf5, 0x50, 0x7c, 0xf2, 0xa6, 0x3a, 0x10, 0xc2, 0x35, 0xc1, 0x58, 0x3e, 0x33,
    0x09, 0x0f, 0xe1, 0x67, 0xb2, 0x1e, 0xa2, 0xa0, 0xc4, 0x27, 0xa4, 0x3d, 0x1a, 0xad, 0xf8,
    0x4f, 0xa4, 0x41, 0xfc, 0x8c, 0xae, 0x3b, 0xef, 0x87, 0x79, 0xc8, 0x5a, 0x6d, 0x23, 0xd7,
    0xb5, 0x7d, 0xd4, 0x88, 0x6c, 0xec, 0x45, 0xcf, 0xca, 0x05, 0xda, 0xb3, 0x41, 0x38, 0xd0,
    0x97, 0x45, 0xec, 0x2d, 0xa4, 0x07, 0xf7, 0x16, 0x5c, 0x78, 0xcc, 0x5f, 0xd1, 0xb0, 0x4f,
    0x02, 0xc0, 0x01, 0x57, 0x1d, 0x36, 0x60, 0xfb, 0x0e, 0x17, 0x68, 0x82, 0x78, 0x11, 0x9b,
    0x9f,

    0x02, 0x03, 0x01, 0x00, 0x01, // start byte of public exponent (e)

    0x02, 0x82, 0x01, 0x00, // private exponent (d)
    0x35, 0x27, 0x01, 0xdc, 0x4c, 0xdb, 0x2d, 0x38, 0xb1, 0xf4, 0xee, 0x73, 0x7f, 0xc4, 0xae,
    0x56, 0x06, 0x66, 0x70, 0xe4, 0xe1, 0x5d, 0x9b, 0xdb, 0xaf, 0x54, 0x62, 0x21, 0x2f, 0xf0,
    0x38, 0x7a, 0x2f, 0x88, 0xe2, 0x6b, 0x08, 0xa0, 0x66, 0x0e, 0xa8, 0x3c, 0x5f, 0xa2, 0xe9,
    0xcf, 0xe0, 0x0f, 0x80, 0xd9, 0xce, 0x55, 0x30, 0x2f, 0x8d, 0xfc, 0xce, 0xce, 0x3a, 0xce,
    0x7f, 0x84, 0xa2, 0x34, 0x64, 0xb7, 0xd8, 0x86, 0xfa, 0x58, 0x8a, 0x99, 0x84, 0x14, 0xce,
    0x18, 0x7d, 0xd0, 0xe7, 0x98, 0x41, 0x90, 0xeb, 0x08, 0x6b, 0xb9, 0xd6, 0x8a, 0x35, 0xe9,
    0x06, 0xfa, 0x70, 0x87, 0xc3, 0x93, 0x2f, 0x27, 0x31, 0xca, 0x8d, 0x41, 0x97, 0x9c, 0xf7,
    0xc2, 0xc0, 0x77, 0x14, 0x7c, 0xa3, 0xca, 0xc7, 0x5c, 0x57, 0x42, 0x58, 0x80, 0x7f, 0x11,
    0xb1, 0xc2, 0x13, 0xf5, 0xbe, 0x0f, 0xcf, 0xd6, 0x4a, 0x95, 0xff, 0x72, 0x2e, 0xa1, 0xdf,
    0x50, 0x26, 0xd6, 0xb1, 0x37, 0x75, 0x25, 0x8e, 0xba, 0x90, 0x94, 0xbc, 0x75, 0x00, 0x01,
    0xc0, 0x51, 0x55, 0xa0, 0x64, 0xe9, 0x68, 0x29, 0x10, 0x8d, 0x06, 0xcc, 0x83, 0x98, 0x92,
    0xe3, 0xee, 0x4c, 0x41, 0x93, 0xd7, 0x6c, 0xe9, 0xec, 0xd5, 0x70, 0x17, 0xcc, 0x5a, 0xbf,
    0x83, 0xc6, 0x05, 0x37, 0x49, 0x21, 0xf5, 0x14, 0xba, 0xef, 0xf9, 0x92, 0x43, 0x4a, 0x2f,
    0x1d, 0xf3, 0x03, 0x17, 0x33, 0x69, 0x12, 0x24, 0x84, 0x4c, 0x24, 0x1b, 0xf8, 0xa8, 0x9c,
    0x90, 0xfe, 0x63, 0x1e, 0x93, 0x7b, 0x9d, 0xef, 0x5f, 0xa8, 0xdc, 0xec, 0x23, 0x1a, 0xf5,
    0xb4, 0x75, 0x69, 0xa0, 0xaf, 0xb1, 0xf3, 0xb6, 0x59, 0x8c, 0x21, 0x04, 0xd3, 0x1d, 0x9e,
    0x64, 0x05, 0xd5, 0xe0, 0xad, 0x04, 0x7b, 0x9b, 0xd3, 0xa3, 0x50, 0x10, 0x64, 0x15, 0xe4,
    0xa9,

    0x02, 0x81, 0x81,
    0x00, // start byte of p factor of N, (prime1, p)
    0xe4, 0xeb, 0x6e, 0xf3, 0x1c, 0x55, 0x8b, 0xd0, 0x43, 0x7a, 0x33, 0xbe, 0xc6, 0x3b, 0x0d,
    0x49, 0x7f, 0x2c, 0xcd, 0x13, 0x6d, 0xc3, 0x33, 0x77, 0x11, 0xf9, 0x52, 0x62, 0xd5, 0xbf,
    0x91, 0x79, 0x7e, 0x01, 0xe5, 0xab, 0x5f, 0x02, 0xee, 0x92, 0xa9, 0xc1, 0x9f, 0xe6, 0xfd,
    0x9f, 0x91, 0xed, 0x0c, 0x1a, 0xb9, 0x51, 0x8f, 0xb7, 0x45, 0xaf, 0xd2, 0x24, 0x59, 0x31,
    0xc3, 0xb4, 0x4d, 0x83, 0xf8, 0x8c, 0xe0, 0x12, 0x98, 0xe1, 0xfe, 0x67, 0xfe, 0x7d, 0x1d,
    0x1c, 0xe9, 0xeb, 0x46, 0xc8, 0x53, 0x01, 0x04, 0xed, 0x79, 0xb3, 0xd7, 0x79, 0x1d, 0xcb,
    0x79, 0x3d, 0x8b, 0xb0, 0xd0, 0x08, 0xec, 0x0a, 0x9a, 0x93, 0xd6, 0xb9, 0x41, 0xd3, 0x60,
    0xb7, 0x7f, 0xfd, 0x88, 0x9b, 0xc1, 0x1d, 0x87, 0x07, 0x27, 0x70, 0x02, 0x22, 0x7e, 0xca,
    0x9f, 0x8a, 0x82, 0x30, 0x23, 0xf4, 0x4e, 0x95,

    0x02, 0x81, 0x81,
    0x00, // start byte of q factor of N (prime2, q)
    0xd9, 0x5f, 0x43, 0x2f, 0x8a, 0x00, 0xef, 0x54, 0x54, 0xbc, 0xf9, 0xcf, 0x60, 0x10, 0x23,
    0x67, 0x2b, 0xb2, 0x76, 0xe4, 0x8f, 0x9e, 0xd5, 0x5f, 0x58, 0x5b, 0x70, 0x80, 0xfe, 0x3c,
    0xe3, 0xa8, 0x5f, 0x7a, 0x06, 0x60, 0xb6, 0x9b, 0x6d, 0x23, 0xe9, 0xe9, 0x8c, 0x97, 0x13,
    0x81, 0x53, 0x4c, 0x22, 0x0a, 0xc9, 0x17, 0xd5, 0xbf, 0x63, 0x6e, 0x6a, 0xb9, 0x3e, 0x9c,
    0x2f, 0x47, 0xdc, 0xcc, 0x4a, 0x97, 0x91, 0x66, 0xb6, 0x31, 0x85, 0x57, 0xc7, 0x9f, 0x33,
    0x76, 0x31, 0xdc, 0xee, 0xa9, 0xd9, 0x9b, 0x3a, 0x2b, 0xd0, 0xe1, 0xa9, 0x00, 0xcc, 0xb1,
    0x8a, 0x4d, 0xef, 0x8b, 0x1e, 0xad, 0x0f, 0x57, 0x53, 0xe7, 0xe6, 0xca, 0x47, 0xed, 0x2a,
    0x59, 0x36, 0x4f, 0x8c, 0x66, 0x0d, 0xcc, 0x73, 0x81, 0x48, 0xc6, 0x65, 0x12, 0x3f, 0x02,
    0x16, 0x89, 0xfd, 0x65, 0x5e, 0x44, 0x58, 0x63,

    0x02, 0x81, 0x81,
    0x00, // start byte of exponent1 (dP), The d mod (p - 1) CRT param
    0xa3, 0xd3, 0xf2, 0x25, 0x3e, 0x63, 0xe2, 0x99, 0x7b, 0x91, 0x1b, 0x33, 0x2e, 0xbe, 0xd8,
    0x35, 0x7f, 0x34, 0x5a, 0xd7, 0xca, 0xb7, 0xe6, 0x3f, 0x12, 0xb7, 0xf1, 0xc4, 0x15, 0xe0,
    0xf1, 0x85, 0x97, 0x2e, 0x58, 0x65, 0x9a, 0xab, 0x88, 0x7d, 0xa1, 0xcb, 0x96, 0x5a, 0x43,
    0xac, 0x4d, 0x4c, 0xee, 0x5a, 0xb9, 0xc1, 0xab, 0x2e, 0xa8, 0x4a, 0xba, 0x03, 0x95, 0x69,
    0xcd, 0xfb, 0x5d, 0x76, 0x53, 0x0c, 0xce, 0xd7, 0xc0, 0x5e, 0x0c, 0x29, 0xf4, 0xb1, 0x29,
    0x82, 0xa5, 0xcd, 0xe1, 0x6c, 0x40, 0x2a, 0xfc, 0x91, 0xcf, 0x85, 0x6b, 0x71, 0x9c, 0x67,
    0x20, 0x2f, 0x71, 0xa7, 0x6a, 0x5a, 0xd8, 0x42, 0x86, 0x79, 0xc3, 0x33, 0xf5, 0xee, 0x06,
    0xcb, 0x8c, 0x67, 0xaf, 0xba, 0x78, 0x2c, 0x5f, 0x94, 0x39, 0x1f, 0x2a, 0x07, 0xf1, 0xe1,
    0xa4, 0xe8, 0x05, 0x5f, 0xda, 0x7b, 0x5f, 0x39,

    0x02, 0x81, 0x80, // start byte of exponent2 (dQ), d mod (q - 1) CRT param
    0x58, 0x27, 0x4c, 0x05, 0xf1, 0x7f, 0xa3, 0x8f, 0x9d, 0xb5, 0xed, 0xd1, 0x6d, 0xf1, 0xdd,
    0x89, 0xaf, 0xac, 0xf6, 0x8e, 0x86, 0xb8, 0x31, 0x6c, 0x33, 0x57, 0x11, 0xef, 0x1e, 0x2b,
    0xef, 0x5f, 0x8f, 0x28, 0xdb, 0x81, 0x49, 0x4d, 0x0b, 0x1b, 0xef, 0x76, 0xe9, 0xaf, 0x33,
    0x17, 0xd5, 0x82, 0x20, 0xa4, 0x23, 0x1d, 0x69, 0x6f, 0xee, 0x91, 0x0e, 0xf3, 0x05, 0x33,
    0x2d, 0xf1, 0x84, 0xd7, 0xcc, 0xc0, 0x5f, 0x15, 0x3a, 0x7a, 0x26, 0xcb, 0x8c, 0x87, 0x41,
    0xc5, 0x83, 0x3f, 0x48, 0x02, 0xd5, 0xdf, 0x1f, 0xde, 0x39, 0x1d, 0xea, 0xfe, 0x0a, 0x05,
    0x4e, 0x43, 0x81, 0x0b, 0xf8, 0x6a, 0xd2, 0xb7, 0xe5, 0xad, 0x3c, 0x69, 0x78, 0x75, 0xf4,
    0x20, 0xad, 0xe7, 0xe0, 0xd6, 0x5a, 0x6e, 0x39, 0xc1, 0x8a, 0x93, 0xfa, 0xd5, 0x45, 0x7c,
    0x41, 0x4b, 0xc0, 0xd9, 0xe5, 0x3a, 0xee, 0x65,

    0x02, 0x81, 0x81,
    0x00, // start byte of coefficient (qP), 1/q mod p CRT param
    0x87, 0x95, 0x06, 0x2d, 0xbd, 0x64, 0x02, 0x24, 0x00, 0xa7, 0x0e, 0x30, 0x12, 0x17, 0x50,
    0xdc, 0x66, 0x98, 0x82, 0x56, 0x51, 0x2d, 0x07, 0xad, 0xae, 0x33, 0x2b, 0xa6, 0xab, 0x34,
    0x4f, 0xb6, 0x43, 0xde, 0x8b, 0x8d, 0xd6, 0x35, 0x94, 0x87, 0x80, 0x53, 0x6b, 0x9d, 0x50,
    0xa6, 0x23, 0x30, 0x62, 0x4a, 0xfc, 0x3b, 0x55, 0x7c, 0x61, 0x03, 0xbd, 0xd5, 0x85, 0xfd,
    0xa3, 0xf8, 0x52, 0x9a, 0x43, 0xeb, 0x66, 0x48, 0xaa, 0xe9, 0x18, 0x78, 0x21, 0x22, 0x45,
    0x56, 0xf3, 0x8a, 0x9b, 0x1c, 0xc7, 0xb6, 0x3e, 0xc3, 0x43, 0x6b, 0x61, 0xb2, 0x90, 0xc7,
    0xe0, 0x6c, 0x79, 0xc2, 0x2d, 0x39, 0x72, 0x6a, 0x2f, 0x01, 0x14, 0xdf, 0x85, 0x68, 0xa2,
    0xfd, 0x90, 0x3e, 0xe9, 0x60, 0x16, 0x7d, 0x70, 0xf0, 0x96, 0x91, 0x73, 0x71, 0xe2, 0xa4,
    0x16, 0x93, 0x8c, 0xbf, 0x90, 0x92, 0xef, 0x28
}; // end of mock_DER_encoded_RSA_privkey_data

static const word16 mock_DER_encoded_RSA_privkey_offset[8] = {
    0x10e, // e, 11 + 0x101 + 0x2
    11,    // N
    0x115, // d, 0x10e + 0x3 + 0x4
    0x218, // p, 0x115 + 0x100 + 0x3
    0x29c, // q,  0x218 + 0x81 + 0x3
    0x427, // qP, 0x3a4 + 0x80 + 0x3
    0x320, // dP, 0x29c + 0x81 + 0x3
    0x3a4, // dQ, 0x320 + 0x81 + 0x3
};

static const word16 mock_DER_encoded_RSA_privkey_len[8] = {
    0x3, 0x101, 0x100, 0x81, 0x81, 0x81, 0x81, 0x80,
};

extern const unsigned int mock_last_mp_from_ubin_max_sz;
extern unsigned int       mock_last_mp_from_ubin_idx;
extern unsigned char     *mock_last_mp_from_ubin_in_data[];
extern size_t             mock_last_mp_from_ubin_in_len[];

tlsRespStatus tlsASN1GetIDlen(const byte *in, word32 *inlen, byte expected_idtag, word32 *datalen) {
    if (in == NULL || inlen == NULL || datalen == NULL) {
        return TLS_RESP_ERRARGS;
    }
    word32        remain_len = 0;
    tlsRespStatus status = TLS_RESP_OK;

    if (expected_idtag != *in++) {
        status = TLS_RESP_ERR_NOT_SUPPORT;
    } else {
        remain_len = *inlen - 1;
        TLS_CFG_ASN1_GET_LEN_FN(status, in, &remain_len, datalen);
        *inlen = 1 + remain_len;
        if (*datalen > TLS_MAX_BYTES_CERT_CHAIN) {
            status = TLS_RESP_ERR_CERT_OVFL;
        }
    }
    return status;
} // end of tlsASN1GetIDlen

// ----------------------------------------------------------------

TEST_GROUP(rsaExtractKeyFromDERencodedMemory);

TEST_SETUP(rsaExtractKeyFromDERencodedMemory) {}

TEST_TEAR_DOWN(rsaExtractKeyFromDERencodedMemory) {}

TEST_GROUP_RUNNER(rsaExtractKeyFromDERencodedMemory) {
    RUN_TEST_CASE(rsaExtractKeyFromDERencodedMemory, public_key);
    RUN_TEST_CASE(rsaExtractKeyFromDERencodedMemory, private_key);
}

TEST(
    rsaExtractKeyFromDERencodedMemory, public_key
) { // the input data of the test is supposed to be DER-encoded bytes sequence that contains RSA
    // public key (N and e)
    tlsRSAkey_t  *pubkey = NULL;
    word32        inlen = 0;
    word32        datalen = 0;
    const byte   *buf = 0;
    tlsRespStatus status = TLS_RESP_OK;

    mock_last_mp_from_ubin_idx = 0;
    buf = &mock_DER_encoded_RSA_pubkey_data[0];
    inlen = DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN;

    TEST_ASSERT_EQUAL_UINT(NULL, pubkey);
    status = tlsRSAgetPubKey(buf, &inlen, (void **)&pubkey, &datalen);
    TEST_ASSERT_EQUAL_INT(TLS_RESP_OK, status);
    TEST_ASSERT_NOT_EQUAL(NULL, pubkey);
    TEST_ASSERT_EQUAL_UINT32(4, inlen);
    TEST_ASSERT_EQUAL_UINT32((DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN - inlen), datalen);

    TEST_ASSERT_EQUAL_UINT32(2, mock_last_mp_from_ubin_idx);
    TEST_ASSERT_EQUAL_UINT(
        &buf[mock_DER_encoded_RSA_pubkey_N_offset], mock_last_mp_from_ubin_in_data[0]
    );
    TEST_ASSERT_EQUAL_UINT16(mock_DER_encoded_RSA_pubkey_N_len, mock_last_mp_from_ubin_in_len[0]);
    TEST_ASSERT_EQUAL_UINT(
        &buf[mock_DER_encoded_RSA_pubkey_e_offset], mock_last_mp_from_ubin_in_data[1]
    );
    TEST_ASSERT_EQUAL_UINT16(mock_DER_encoded_RSA_pubkey_e_len, mock_last_mp_from_ubin_in_len[1]);

    tlsRSAfreePubKey((void *)pubkey);
} // end of TEST(rsaExtractKeyFromDERencodedMemory, public_key)

TEST(rsaExtractKeyFromDERencodedMemory, private_key) {
    tlsRSAkey_t  *privkey = NULL;
    word16        inlen = 0;
    const byte   *buf = 0;
    tlsRespStatus status = TLS_RESP_OK;
    byte          idx = 0;

    mock_last_mp_from_ubin_idx = 0;
    buf = &mock_DER_encoded_RSA_privkey_data[0];
    inlen = DER_ENCODED_RSA_PRIVKEY_RAWBYTES_LEN;

    TEST_ASSERT_EQUAL_UINT(NULL, privkey);
    status = tlsRSAgetPrivKey(buf, inlen, (void **)&privkey);
    TEST_ASSERT_EQUAL_INT(TLS_RESP_OK, status);
    TEST_ASSERT_NOT_EQUAL(NULL, privkey);

    TEST_ASSERT_EQUAL_UINT32(8, mock_last_mp_from_ubin_idx);
    for (idx = 0; idx < mock_last_mp_from_ubin_idx; idx++) {
        TEST_ASSERT_EQUAL_UINT(
            &buf[mock_DER_encoded_RSA_privkey_offset[idx]], mock_last_mp_from_ubin_in_data[idx]
        );
        TEST_ASSERT_EQUAL_UINT16(
            mock_DER_encoded_RSA_privkey_len[idx], mock_last_mp_from_ubin_in_len[idx]
        );
    }
    tlsRSAfreePrivKey((void *)privkey);
} // end of TEST(rsaExtractKeyFromDERencodedMemory, private_key)

static void RunAllTestGroups(void) {
    RUN_TEST_GROUP(rsaExtractKeyFromDERencodedMemory);
} // end of RunAllTestGroups

int main(int argc, const char *argv[]) {
    return UnityMain(argc, argv, RunAllTestGroups);
} // end of main
