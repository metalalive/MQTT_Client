#include "mqtt_include.h"
#include "unity.h"
#include "unity_fixture.h"

#define  DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN   0x113
#define  DER_ENCODED_RSA_PRIVKEY_RAWBYTES_LEN  0x4a8

static const byte mock_DER_encoded_RSA_pubkey_data[DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN] = {
    0x03, 0x82, 0x01, 0x0f, 
    0x00, 0x30, 0x82, 0x01, 0x0a,
        0x02, 0x82, 0x01, 0x01, // length field of modulus (N) of public key = 0x101
            0x00, // start of modulus (N) of public key, the first byte must be NULL
            0xc2, 0x60, 0xc0, 0x7e, 0x5f, 0xe6, 0xc6, 0x21, 0x45, 0xa9, 0x86, 0x62, 0x65, 0xcc, 0x01, 0x1f,
            0xd2, 0xb1, 0xe4, 0xef, 0x46, 0xac, 0xaa, 0x3c, 0xd0, 0x46, 0x6a, 0xbb, 0x13, 0x84, 0xde, 0xb5,
            0x29, 0x57, 0x6f, 0xf3, 0x21, 0x42, 0xef, 0x42, 0x45, 0x9c, 0x60, 0x0a, 0xa6, 0x0f, 0x23, 0xe3,
            0x9d, 0x56, 0xa7, 0xa9, 0x78, 0x29, 0x3a, 0x8f, 0x1e, 0x1c, 0xf6, 0xda, 0x90, 0x59, 0xd9, 0x21,
            0x91, 0x86, 0x1c, 0x3d, 0x1f, 0x93, 0xbb, 0xdc, 0x9c, 0x98, 0x89, 0x70, 0x7e, 0x11, 0xee, 0xf5,
            0xdc, 0x29, 0x60, 0xaf, 0x66, 0xab, 0x5d, 0x9c, 0x19, 0x04, 0x2b, 0x6b, 0x24, 0xe6, 0x9e, 0x01,
            0x35, 0xd8, 0x63, 0x1a, 0xe9, 0xd8, 0x9d, 0x57, 0x92, 0x66, 0xf0, 0xba, 0x1e, 0x14, 0x7d, 0x12,
            0x07, 0x9d, 0x95, 0xf5, 0x65, 0xad, 0x83, 0x44, 0x4e, 0xd9, 0x78, 0x34, 0x7b, 0xac, 0x25, 0x67,
            0xfc, 0x8c, 0xb1, 0x4f, 0x34, 0x9d, 0xca, 0x61, 0xb8, 0xcf, 0xbd, 0xdd, 0x17, 0xdd, 0xbc, 0xc5,
            0x0e, 0x74, 0xe2, 0xe2, 0x78, 0x12, 0x92, 0x79, 0x55, 0x83, 0x9b, 0xf5, 0xf1, 0x3f, 0x97, 0xb0,
            0x55, 0x69, 0xe6, 0x6f, 0x3a, 0x8d, 0x63, 0xf5, 0x50, 0x7c, 0xf2, 0xa6, 0x3a, 0x10, 0xc2, 0x35,
            0xc1, 0x58, 0x3e, 0x33, 0x09, 0x0f, 0xe1, 0x67, 0xb2, 0x1e, 0xa2, 0xa0, 0xc4, 0x27, 0xa4, 0x3d,
            0x1a, 0xad, 0xf8, 0x4f, 0xa4, 0x41, 0xfc, 0x8c, 0xae, 0x3b, 0xef, 0x87, 0x79, 0xc8, 0x5a, 0x6d,
            0x23, 0xd7, 0xb5, 0x7d, 0xd4, 0x88, 0x6c, 0xec, 0x45, 0xcf, 0xca, 0x05, 0xda, 0xb3, 0x41, 0x38,
            0xd0, 0x97, 0x45, 0xec, 0x2d, 0xa4, 0x07, 0xf7, 0x16, 0x5c, 0x78, 0xcc, 0x5f, 0xd1, 0xb0, 0x4f,
            0x02, 0xc0, 0x01, 0x57, 0x1d, 0x36, 0x60, 0xfb, 0x0e, 0x17, 0x68, 0x82, 0x78, 0x11, 0x9b, 0x9f,
        0x02, 0x03, // length field of exponent (e) of public key = 0x3
            0x01, 0x00, 0x01,
}; // end of mock_DER_encoded_RSA_pubkey_data

static const word16 mock_DER_encoded_RSA_pubkey_N_offset = 13;
static const word16 mock_DER_encoded_RSA_pubkey_N_len    = 0x101;
static const word16 mock_DER_encoded_RSA_pubkey_e_offset = 0x110;
static const word16 mock_DER_encoded_RSA_pubkey_e_len    = 0x3;

static const byte mock_DER_encoded_RSA_privkey_data[DER_ENCODED_RSA_PRIVKEY_RAWBYTES_LEN] = {
  0x30, 0x82, 0x04, 0xa4,
      0x02, 0x01, 0x00,
          0x02, 0x82, 0x01, 0x01,
              0x00, // start byte of modulus (N), which should be NULL
              0xc2, 0x60, 0xc0, 0x7e, 0x5f, 0xe6, 0xc6, 0x21, 0x45, 0xa9, 0x86, 0x62, 0x65, 0xcc, 0x01, 0x1f,
              0xd2, 0xb1, 0xe4, 0xef, 0x46, 0xac, 0xaa, 0x3c, 0xd0, 0x46, 0x6a, 0xbb, 0x13, 0x84, 0xde, 0xb5,
              0x29, 0x57, 0x6f, 0xf3, 0x21, 0x42, 0xef, 0x42, 0x45, 0x9c, 0x60, 0x0a, 0xa6, 0x0f, 0x23, 0xe3,
              0x9d, 0x56, 0xa7, 0xa9, 0x78, 0x29, 0x3a, 0x8f, 0x1e, 0x1c, 0xf6, 0xda, 0x90, 0x59, 0xd9, 0x21,
              0x91, 0x86, 0x1c, 0x3d, 0x1f, 0x93, 0xbb, 0xdc, 0x9c, 0x98, 0x89, 0x70, 0x7e, 0x11, 0xee, 0xf5,
              0xdc, 0x29, 0x60, 0xaf, 0x66, 0xab, 0x5d, 0x9c, 0x19, 0x04, 0x2b, 0x6b, 0x24, 0xe6, 0x9e, 0x01,
              0x35, 0xd8, 0x63, 0x1a, 0xe9, 0xd8, 0x9d, 0x57, 0x92, 0x66, 0xf0, 0xba, 0x1e, 0x14, 0x7d, 0x12,
              0x07, 0x9d, 0x95, 0xf5, 0x65, 0xad, 0x83, 0x44, 0x4e, 0xd9, 0x78, 0x34, 0x7b, 0xac, 0x25, 0x67,
              0xfc, 0x8c, 0xb1, 0x4f, 0x34, 0x9d, 0xca, 0x61, 0xb8, 0xcf, 0xbd, 0xdd, 0x17, 0xdd, 0xbc, 0xc5,
              0x0e, 0x74, 0xe2, 0xe2, 0x78, 0x12, 0x92, 0x79, 0x55, 0x83, 0x9b, 0xf5, 0xf1, 0x3f, 0x97, 0xb0,
              0x55, 0x69, 0xe6, 0x6f, 0x3a, 0x8d, 0x63, 0xf5, 0x50, 0x7c, 0xf2, 0xa6, 0x3a, 0x10, 0xc2, 0x35,
              0xc1, 0x58, 0x3e, 0x33, 0x09, 0x0f, 0xe1, 0x67, 0xb2, 0x1e, 0xa2, 0xa0, 0xc4, 0x27, 0xa4, 0x3d,
              0x1a, 0xad, 0xf8, 0x4f, 0xa4, 0x41, 0xfc, 0x8c, 0xae, 0x3b, 0xef, 0x87, 0x79, 0xc8, 0x5a, 0x6d,
              0x23, 0xd7, 0xb5, 0x7d, 0xd4, 0x88, 0x6c, 0xec, 0x45, 0xcf, 0xca, 0x05, 0xda, 0xb3, 0x41, 0x38,
              0xd0, 0x97, 0x45, 0xec, 0x2d, 0xa4, 0x07, 0xf7, 0x16, 0x5c, 0x78, 0xcc, 0x5f, 0xd1, 0xb0, 0x4f,
              0x02, 0xc0, 0x01, 0x57, 0x1d, 0x36, 0x60, 0xfb, 0x0e, 0x17, 0x68, 0x82, 0x78, 0x11, 0x9b, 0x9f,

          0x02, 0x03,
              0x01, 0x00, 0x01, // start byte of public exponent (e)

          0x02, 0x82, 0x01, 0x00, // private exponent (d)
              0x35, 0x27, 0x01, 0xdc, 0x4c, 0xdb, 0x2d, 0x38, 0xb1, 0xf4, 0xee, 0x73, 0x7f, 0xc4, 0xae, 0x56,
              0x06, 0x66, 0x70, 0xe4, 0xe1, 0x5d, 0x9b, 0xdb, 0xaf, 0x54, 0x62, 0x21, 0x2f, 0xf0, 0x38, 0x7a,
              0x2f, 0x88, 0xe2, 0x6b, 0x08, 0xa0, 0x66, 0x0e, 0xa8, 0x3c, 0x5f, 0xa2, 0xe9, 0xcf, 0xe0, 0x0f,
              0x80, 0xd9, 0xce, 0x55, 0x30, 0x2f, 0x8d, 0xfc, 0xce, 0xce, 0x3a, 0xce, 0x7f, 0x84, 0xa2, 0x34,
              0x64, 0xb7, 0xd8, 0x86, 0xfa, 0x58, 0x8a, 0x99, 0x84, 0x14, 0xce, 0x18, 0x7d, 0xd0, 0xe7, 0x98,
              0x41, 0x90, 0xeb, 0x08, 0x6b, 0xb9, 0xd6, 0x8a, 0x35, 0xe9, 0x06, 0xfa, 0x70, 0x87, 0xc3, 0x93,
              0x2f, 0x27, 0x31, 0xca, 0x8d, 0x41, 0x97, 0x9c, 0xf7, 0xc2, 0xc0, 0x77, 0x14, 0x7c, 0xa3, 0xca,
              0xc7, 0x5c, 0x57, 0x42, 0x58, 0x80, 0x7f, 0x11, 0xb1, 0xc2, 0x13, 0xf5, 0xbe, 0x0f, 0xcf, 0xd6,
              0x4a, 0x95, 0xff, 0x72, 0x2e, 0xa1, 0xdf, 0x50, 0x26, 0xd6, 0xb1, 0x37, 0x75, 0x25, 0x8e, 0xba,
              0x90, 0x94, 0xbc, 0x75, 0x00, 0x01, 0xc0, 0x51, 0x55, 0xa0, 0x64, 0xe9, 0x68, 0x29, 0x10, 0x8d,
              0x06, 0xcc, 0x83, 0x98, 0x92, 0xe3, 0xee, 0x4c, 0x41, 0x93, 0xd7, 0x6c, 0xe9, 0xec, 0xd5, 0x70,
              0x17, 0xcc, 0x5a, 0xbf, 0x83, 0xc6, 0x05, 0x37, 0x49, 0x21, 0xf5, 0x14, 0xba, 0xef, 0xf9, 0x92,
              0x43, 0x4a, 0x2f, 0x1d, 0xf3, 0x03, 0x17, 0x33, 0x69, 0x12, 0x24, 0x84, 0x4c, 0x24, 0x1b, 0xf8,
              0xa8, 0x9c, 0x90, 0xfe, 0x63, 0x1e, 0x93, 0x7b, 0x9d, 0xef, 0x5f, 0xa8, 0xdc, 0xec, 0x23, 0x1a,
              0xf5, 0xb4, 0x75, 0x69, 0xa0, 0xaf, 0xb1, 0xf3, 0xb6, 0x59, 0x8c, 0x21, 0x04, 0xd3, 0x1d, 0x9e,
              0x64, 0x05, 0xd5, 0xe0, 0xad, 0x04, 0x7b, 0x9b, 0xd3, 0xa3, 0x50, 0x10, 0x64, 0x15, 0xe4, 0xa9,

          0x02, 0x81, 0x81,
              0x00, // start byte of p factor of N, (prime1, p)
              0xe4, 0xeb, 0x6e, 0xf3, 0x1c, 0x55, 0x8b, 0xd0, 0x43, 0x7a, 0x33, 0xbe, 0xc6, 0x3b, 0x0d, 0x49,
              0x7f, 0x2c, 0xcd, 0x13, 0x6d, 0xc3, 0x33, 0x77, 0x11, 0xf9, 0x52, 0x62, 0xd5, 0xbf, 0x91, 0x79,
              0x7e, 0x01, 0xe5, 0xab, 0x5f, 0x02, 0xee, 0x92, 0xa9, 0xc1, 0x9f, 0xe6, 0xfd, 0x9f, 0x91, 0xed,
              0x0c, 0x1a, 0xb9, 0x51, 0x8f, 0xb7, 0x45, 0xaf, 0xd2, 0x24, 0x59, 0x31, 0xc3, 0xb4, 0x4d, 0x83,
              0xf8, 0x8c, 0xe0, 0x12, 0x98, 0xe1, 0xfe, 0x67, 0xfe, 0x7d, 0x1d, 0x1c, 0xe9, 0xeb, 0x46, 0xc8,
              0x53, 0x01, 0x04, 0xed, 0x79, 0xb3, 0xd7, 0x79, 0x1d, 0xcb, 0x79, 0x3d, 0x8b, 0xb0, 0xd0, 0x08,
              0xec, 0x0a, 0x9a, 0x93, 0xd6, 0xb9, 0x41, 0xd3, 0x60, 0xb7, 0x7f, 0xfd, 0x88, 0x9b, 0xc1, 0x1d,
              0x87, 0x07, 0x27, 0x70, 0x02, 0x22, 0x7e, 0xca, 0x9f, 0x8a, 0x82, 0x30, 0x23, 0xf4, 0x4e, 0x95,

          0x02, 0x81, 0x81,
              0x00, // start byte of q factor of N (prime2, q)
              0xd9, 0x5f, 0x43, 0x2f, 0x8a, 0x00, 0xef, 0x54, 0x54, 0xbc, 0xf9, 0xcf, 0x60, 0x10, 0x23, 0x67,
              0x2b, 0xb2, 0x76, 0xe4, 0x8f, 0x9e, 0xd5, 0x5f, 0x58, 0x5b, 0x70, 0x80, 0xfe, 0x3c, 0xe3, 0xa8,
              0x5f, 0x7a, 0x06, 0x60, 0xb6, 0x9b, 0x6d, 0x23, 0xe9, 0xe9, 0x8c, 0x97, 0x13, 0x81, 0x53, 0x4c,
              0x22, 0x0a, 0xc9, 0x17, 0xd5, 0xbf, 0x63, 0x6e, 0x6a, 0xb9, 0x3e, 0x9c, 0x2f, 0x47, 0xdc, 0xcc,
              0x4a, 0x97, 0x91, 0x66, 0xb6, 0x31, 0x85, 0x57, 0xc7, 0x9f, 0x33, 0x76, 0x31, 0xdc, 0xee, 0xa9,
              0xd9, 0x9b, 0x3a, 0x2b, 0xd0, 0xe1, 0xa9, 0x00, 0xcc, 0xb1, 0x8a, 0x4d, 0xef, 0x8b, 0x1e, 0xad,
              0x0f, 0x57, 0x53, 0xe7, 0xe6, 0xca, 0x47, 0xed, 0x2a, 0x59, 0x36, 0x4f, 0x8c, 0x66, 0x0d, 0xcc,
              0x73, 0x81, 0x48, 0xc6, 0x65, 0x12, 0x3f, 0x02, 0x16, 0x89, 0xfd, 0x65, 0x5e, 0x44, 0x58, 0x63,

         0x02, 0x81, 0x81,
             0x00, // start byte of exponent1 (dP), The d mod (p - 1) CRT param
             0xa3, 0xd3, 0xf2, 0x25, 0x3e, 0x63, 0xe2, 0x99, 0x7b, 0x91, 0x1b, 0x33, 0x2e, 0xbe, 0xd8, 0x35,
             0x7f, 0x34, 0x5a, 0xd7, 0xca, 0xb7, 0xe6, 0x3f, 0x12, 0xb7, 0xf1, 0xc4, 0x15, 0xe0, 0xf1, 0x85,
             0x97, 0x2e, 0x58, 0x65, 0x9a, 0xab, 0x88, 0x7d, 0xa1, 0xcb, 0x96, 0x5a, 0x43, 0xac, 0x4d, 0x4c,
             0xee, 0x5a, 0xb9, 0xc1, 0xab, 0x2e, 0xa8, 0x4a, 0xba, 0x03, 0x95, 0x69, 0xcd, 0xfb, 0x5d, 0x76,
             0x53, 0x0c, 0xce, 0xd7, 0xc0, 0x5e, 0x0c, 0x29, 0xf4, 0xb1, 0x29, 0x82, 0xa5, 0xcd, 0xe1, 0x6c,
             0x40, 0x2a, 0xfc, 0x91, 0xcf, 0x85, 0x6b, 0x71, 0x9c, 0x67, 0x20, 0x2f, 0x71, 0xa7, 0x6a, 0x5a,
             0xd8, 0x42, 0x86, 0x79, 0xc3, 0x33, 0xf5, 0xee, 0x06, 0xcb, 0x8c, 0x67, 0xaf, 0xba, 0x78, 0x2c,
             0x5f, 0x94, 0x39, 0x1f, 0x2a, 0x07, 0xf1, 0xe1, 0xa4, 0xe8, 0x05, 0x5f, 0xda, 0x7b, 0x5f, 0x39,

         0x02, 0x81, 0x80, // start byte of exponent2 (dQ), d mod (q - 1) CRT param
             0x58, 0x27, 0x4c, 0x05, 0xf1, 0x7f, 0xa3, 0x8f, 0x9d, 0xb5, 0xed, 0xd1, 0x6d, 0xf1, 0xdd, 0x89,
             0xaf, 0xac, 0xf6, 0x8e, 0x86, 0xb8, 0x31, 0x6c, 0x33, 0x57, 0x11, 0xef, 0x1e, 0x2b, 0xef, 0x5f,
             0x8f, 0x28, 0xdb, 0x81, 0x49, 0x4d, 0x0b, 0x1b, 0xef, 0x76, 0xe9, 0xaf, 0x33, 0x17, 0xd5, 0x82,
             0x20, 0xa4, 0x23, 0x1d, 0x69, 0x6f, 0xee, 0x91, 0x0e, 0xf3, 0x05, 0x33, 0x2d, 0xf1, 0x84, 0xd7,
             0xcc, 0xc0, 0x5f, 0x15, 0x3a, 0x7a, 0x26, 0xcb, 0x8c, 0x87, 0x41, 0xc5, 0x83, 0x3f, 0x48, 0x02,
             0xd5, 0xdf, 0x1f, 0xde, 0x39, 0x1d, 0xea, 0xfe, 0x0a, 0x05, 0x4e, 0x43, 0x81, 0x0b, 0xf8, 0x6a,
             0xd2, 0xb7, 0xe5, 0xad, 0x3c, 0x69, 0x78, 0x75, 0xf4, 0x20, 0xad, 0xe7, 0xe0, 0xd6, 0x5a, 0x6e,
             0x39, 0xc1, 0x8a, 0x93, 0xfa, 0xd5, 0x45, 0x7c, 0x41, 0x4b, 0xc0, 0xd9, 0xe5, 0x3a, 0xee, 0x65,

         0x02, 0x81, 0x81,
             0x00, // start byte of coefficient (qP), 1/q mod p CRT param
             0x87, 0x95, 0x06, 0x2d, 0xbd, 0x64, 0x02, 0x24, 0x00, 0xa7, 0x0e, 0x30, 0x12, 0x17, 0x50, 0xdc,
             0x66, 0x98, 0x82, 0x56, 0x51, 0x2d, 0x07, 0xad, 0xae, 0x33, 0x2b, 0xa6, 0xab, 0x34, 0x4f, 0xb6,
             0x43, 0xde, 0x8b, 0x8d, 0xd6, 0x35, 0x94, 0x87, 0x80, 0x53, 0x6b, 0x9d, 0x50, 0xa6, 0x23, 0x30,
             0x62, 0x4a, 0xfc, 0x3b, 0x55, 0x7c, 0x61, 0x03, 0xbd, 0xd5, 0x85, 0xfd, 0xa3, 0xf8, 0x52, 0x9a,
             0x43, 0xeb, 0x66, 0x48, 0xaa, 0xe9, 0x18, 0x78, 0x21, 0x22, 0x45, 0x56, 0xf3, 0x8a, 0x9b, 0x1c,
             0xc7, 0xb6, 0x3e, 0xc3, 0x43, 0x6b, 0x61, 0xb2, 0x90, 0xc7, 0xe0, 0x6c, 0x79, 0xc2, 0x2d, 0x39,
             0x72, 0x6a, 0x2f, 0x01, 0x14, 0xdf, 0x85, 0x68, 0xa2, 0xfd, 0x90, 0x3e, 0xe9, 0x60, 0x16, 0x7d,
             0x70, 0xf0, 0x96, 0x91, 0x73, 0x71, 0xe2, 0xa4, 0x16, 0x93, 0x8c, 0xbf, 0x90, 0x92, 0xef, 0x28
}; // end of mock_DER_encoded_RSA_privkey_data

static const word16 mock_DER_encoded_RSA_privkey_offset[8] = {
    0x10e, // e, 11 + 0x101 + 0x2
    11,    // N
    0x115, // d, 0x10e + 0x3 + 0x4
    0x218, // p, 0x115 + 0x100 + 0x3
    0x29c, // q,  0x218 + 0x81 + 0x3
    0x427, // qP, 0x3a4 + 0x80 + 0x3
    0x320, // dP, 0x29c + 0x81 + 0x3
    0x3a4, // dQ, 0x320 + 0x81 + 0x3
};

static const word16 mock_DER_encoded_RSA_privkey_len[8] = {
    0x3, 0x101, 0x100, 0x81, 0x81, 0x81, 0x81, 0x80,
};




extern const  unsigned int mock_last_mp_from_ubin_max_sz;
extern unsigned int   mock_last_mp_from_ubin_idx;
extern unsigned char *mock_last_mp_from_ubin_in_data[];
extern size_t         mock_last_mp_from_ubin_in_len[];


tlsRespStatus  tlsASN1GetIDlen(const byte *in, word32 *inlen, byte expected_idtag, word32 *datalen)
{
    if(in == NULL || inlen == NULL || datalen == NULL) {
        return TLS_RESP_ERRARGS;
    }
    word32    remain_len = 0;
    tlsRespStatus status = TLS_RESP_OK;

    if(expected_idtag != *in++) {
        status = TLS_RESP_ERR_NOT_SUPPORT;
    } else {
        remain_len = *inlen - 1;
        TLS_CFG_ASN1_GET_LEN_FN(status, in, &remain_len, datalen);
        *inlen = 1 + remain_len;
        if(*datalen > TLS_MAX_BYTES_CERT_CHAIN) {
            status = TLS_RESP_ERR_CERT_OVFL;
        }
    }
    return status;
} // end of tlsASN1GetIDlen


// ----------------------------------------------------------------

TEST_GROUP(rsaExtractKeyFromDERencodedMemory);

TEST_SETUP(rsaExtractKeyFromDERencodedMemory)
{}

TEST_TEAR_DOWN(rsaExtractKeyFromDERencodedMemory)
{}

TEST_GROUP_RUNNER(rsaExtractKeyFromDERencodedMemory)
{
    RUN_TEST_CASE(rsaExtractKeyFromDERencodedMemory, public_key);
    RUN_TEST_CASE(rsaExtractKeyFromDERencodedMemory, private_key);
}


TEST(rsaExtractKeyFromDERencodedMemory, public_key)
{ // the input data of the test is supposed to be DER-encoded bytes sequence that contains RSA public key (N and e)
    tlsRSAkey_t   *pubkey = NULL;
    word32         inlen  = 0;
    word32         datalen = 0;
    const byte    *buf = 0;
    tlsRespStatus  status = TLS_RESP_OK;

    mock_last_mp_from_ubin_idx = 0;
    buf = &mock_DER_encoded_RSA_pubkey_data[0];
    inlen = DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN;

    TEST_ASSERT_EQUAL_UINT(NULL, pubkey);
    status = tlsRSAgetPubKey(buf, &inlen, (void **)&pubkey, &datalen);
    TEST_ASSERT_EQUAL_INT(TLS_RESP_OK, status);
    TEST_ASSERT_NOT_EQUAL(NULL, pubkey);
    TEST_ASSERT_EQUAL_UINT32(4, inlen);
    TEST_ASSERT_EQUAL_UINT32((DER_ENCODED_RSA_PUBKEY_RAWBYTES_LEN - inlen), datalen);

    TEST_ASSERT_EQUAL_UINT32(2, mock_last_mp_from_ubin_idx);
    TEST_ASSERT_EQUAL_UINT(&buf[mock_DER_encoded_RSA_pubkey_N_offset], mock_last_mp_from_ubin_in_data[0]);
    TEST_ASSERT_EQUAL_UINT16(mock_DER_encoded_RSA_pubkey_N_len, mock_last_mp_from_ubin_in_len[0]);
    TEST_ASSERT_EQUAL_UINT(&buf[mock_DER_encoded_RSA_pubkey_e_offset], mock_last_mp_from_ubin_in_data[1]);
    TEST_ASSERT_EQUAL_UINT16(mock_DER_encoded_RSA_pubkey_e_len, mock_last_mp_from_ubin_in_len[1]);

    tlsRSAfreePubKey((void *)pubkey);
} // end of TEST(rsaExtractKeyFromDERencodedMemory, public_key)


TEST(rsaExtractKeyFromDERencodedMemory, private_key)
{
    tlsRSAkey_t   *privkey = NULL;
    word16         inlen  = 0;
    const byte    *buf = 0;
    tlsRespStatus  status = TLS_RESP_OK;
    byte           idx = 0;

    mock_last_mp_from_ubin_idx = 0;
    buf = &mock_DER_encoded_RSA_privkey_data[0];
    inlen = DER_ENCODED_RSA_PRIVKEY_RAWBYTES_LEN;

    TEST_ASSERT_EQUAL_UINT(NULL, privkey);
    status = tlsRSAgetPrivKey(buf, inlen, (void **)&privkey);
    TEST_ASSERT_EQUAL_INT(TLS_RESP_OK, status);
    TEST_ASSERT_NOT_EQUAL(NULL, privkey);

    TEST_ASSERT_EQUAL_UINT32(8, mock_last_mp_from_ubin_idx);
    for(idx = 0; idx < mock_last_mp_from_ubin_idx; idx++) {
        TEST_ASSERT_EQUAL_UINT(&buf[mock_DER_encoded_RSA_privkey_offset[idx]], mock_last_mp_from_ubin_in_data[idx]);
        TEST_ASSERT_EQUAL_UINT16(mock_DER_encoded_RSA_privkey_len[idx], mock_last_mp_from_ubin_in_len[idx]);
    }
    tlsRSAfreePrivKey((void *)privkey);
} // end of TEST(rsaExtractKeyFromDERencodedMemory, private_key)




static void RunAllTestGroups(void)
{
    RUN_TEST_GROUP(rsaExtractKeyFromDERencodedMemory);
} // end of RunAllTestGroups


int main(int argc, const char *argv[])
{
    return UnityMain(argc, argv, RunAllTestGroups);
} // end of main


